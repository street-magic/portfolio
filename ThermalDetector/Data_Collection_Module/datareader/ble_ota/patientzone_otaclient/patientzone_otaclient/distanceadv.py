import logging
from dataclasses import dataclass, field
from typing import List


ROI_LSB_TO_CM = 2

COMMON_BYTES_LEN = 3

LOG = logging.getLogger("otaClient")
LOG_DIST_ADV = LOG.getChild("distanceAdv")

def nosoexDecrypt(bytes_):
  key = 161
  offset = 47
  decrypted = b""

  for byte in bytes_:
    b = ((byte - offset) ^ key) & 0xff
    decrypted += b.to_bytes(1, "little")
    offset = byte

  return decrypted

def nosoexCrc(bytes_):
  key=165
  crc = key

  for byte in bytes_:
    crc ^= byte

  return crc


@dataclass
class DistanceAdv:
  roisCm: List[int] = field(default_factory=list)
  batteryMv: int = 0
  pirCount: int = 0
  luminance: int = 0
  accelX: int = 0
  accelY: int = 0
  accelZ: int = 0
  crc: int = 0

  def __post_init__(self):  # __init__ should not be touched cause its generated by dataclass
    self._page0Bytes = None
    self._page1Bytes = None
    self._complete = False

  def isComplete(self):
    return self._complete

  def getSignedNumber(self, number, bitLength):
    mask = (2 ** bitLength) - 1
    if number & (1 << (bitLength - 1)):
      return number | ~mask
    else:
      return number & mask

  def feedWithAdvBytes(self, bytes_ : bytes):
    """takes manufacture bytes from ble patientzone adv in right order and then builds an object out of it"""

    if self.isComplete() or not bytes_:
      return;

    # packetId == patientzone?
    packetId = int(bytes_[0])
    if packetId != 0x13:
      LOG_DIST_ADV.debug("packetId wrong. expected: 0x13. actual: " + hex(packetId))
      return None

    # decrypt
    decrypted = bytes_[:2] + nosoexDecrypt(bytes_[2:])  # 2 first bytes are not encrypted
    LOG_DIST_ADV.debug("decrypted: " + str([hex(x) for x in decrypted]))

    # get page number
    pageNumber = (decrypted[2] & 0b0110_0000) >> 5
    if pageNumber in [0, 1]:
      LOG_DIST_ADV.info("found page number: " + str(pageNumber))
    else:
      LOG_DIST_ADV.warning("page number wrong. expected: [0, 1], actual: " + str(pageNumber))

    if pageNumber == 0 and self._page0Bytes == None:
        self._page0Bytes = decrypted
        LOG_DIST_ADV.info("adding page number: " + str(pageNumber))
    elif pageNumber == 1 and self._page1Bytes == None and self._page0Bytes != None:
        self._page1Bytes = decrypted
        LOG_DIST_ADV.info("adding page number: " + str(pageNumber))

    if self._page0Bytes != None and self._page1Bytes != None:
      LOG_DIST_ADV.info("found all pages. initialize adv data")

      # crc ok? not? -> discard everything
      crc = nosoexCrc(self._page0Bytes[COMMON_BYTES_LEN:] + self._page1Bytes[COMMON_BYTES_LEN:])
      if self.crc != crc:
        LOG_DIST_ADV.warning("crc invalid. expected: " + hex(crc) + ". actual: " + hex(self.crc) + ". discarding all pages")
        self._page0Bytes = None
        self._page1Bytes = None
        return

      # get stuff from page 0
      for i in range(14):
        self.roisCm.append(self._page0Bytes[COMMON_BYTES_LEN + 2 + i] * ROI_LSB_TO_CM)

      # get stuff from page 1
      self.roisCm.append(self._page1Bytes[COMMON_BYTES_LEN] * ROI_LSB_TO_CM)
      self.roisCm.append(self._page1Bytes[COMMON_BYTES_LEN + 1] * ROI_LSB_TO_CM)
      self.batteryMv = (self._page1Bytes[COMMON_BYTES_LEN + 3] << 8) | self._page1Bytes[COMMON_BYTES_LEN + 2]
      self.pirCount  = self._page1Bytes[COMMON_BYTES_LEN + 4]
      self.luminance = self._page1Bytes[COMMON_BYTES_LEN + 5]
      self.accelX    = self.getSignedNumber(self._page1Bytes[COMMON_BYTES_LEN + 6], 8) * 2000 / 256
      self.accelY    = self.getSignedNumber(self._page1Bytes[COMMON_BYTES_LEN + 7], 8) * 2000 / 256
      self.accelZ    = self.getSignedNumber(self._page1Bytes[COMMON_BYTES_LEN + 8], 8) * 2000 / 256
      self.crc       = self._page1Bytes[COMMON_BYTES_LEN + 9]

      self._complete = True
